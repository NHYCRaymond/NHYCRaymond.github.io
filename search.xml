<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Godot4中Button与Label的使用</title>
      <link href="/nhycraymond/2023/12/26/Godot4%E4%B8%ADButton%E4%B8%8ELabel%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/nhycraymond/2023/12/26/Godot4%E4%B8%ADButton%E4%B8%8ELabel%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><h2 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h2><ol><li>Text（文本）： 设置按钮显示的文本内容。</li><li>Normal, Hover, Pressed Text（正常状态、悬停状态、按下状态的文本）： 分别设置按钮在不同状态下的文本内容。</li><li>Icon（图标）： 设置按钮的图标，通常与文本一起使用。</li><li>Disabled（禁用）： 布尔值，设置按钮是否处于禁用状态。</li><li>Disabled Modulate（禁用模式）： 设置按钮禁用状态下的外观，可以改变按钮的颜色或透明度。</li><li>Focus Mode（焦点模式）： 设置按钮获取焦点的方式，比如按下 Tab 键时是否能够获取焦点。</li><li>Shortcut（快捷键）： 为按钮设置一个快捷键，当按下快捷键时触发按钮点击事件。</li><li>Toggle Mode（切换模式）： 布尔值，设置按钮是否处于切换模式，即点击按钮会切换按钮的状态。</li></ol><h2 id="样式和外观属性："><a href="#样式和外观属性：" class="headerlink" title="样式和外观属性："></a>样式和外观属性：</h2><ol><li>Custom Styles（自定义样式）： 允许为按钮的不同状态（Normal、Hover、Pressed 等）设置自定义样式。</li><li>Normal, Hover, Pressed Modulate（正常状态、悬停状态、按下状态的模态）： 分别设置按钮在不同状态下的颜色或透明度。</li><li>Theme（主题）： 通过主题设置按钮的样式和外观。</li></ol><h2 id="交互事件和信号属性："><a href="#交互事件和信号属性：" class="headerlink" title="交互事件和信号属性："></a>交互事件和信号属性：</h2><ol><li>Pressed（按下）： 按钮被按下时触发的信号。</li><li>Toggled（切换）： 切换模式下，按钮状态改变时触发的信号。</li><li>Button Group（按钮组）： 可以将多个按钮放置在同一个组中，以便于管理和控制这些按钮的行为。</li></ol><h2 id="其他属性："><a href="#其他属性：" class="headerlink" title="其他属性："></a>其他属性：</h2><ol><li>Rect Min Size（最小尺寸）： 设置按钮的最小尺寸。</li><li>Rect Clip Content（剪辑内容）： 布尔值，确定按钮是否应该裁剪超出其边界的内容。</li></ol><p><img src="/images/Godot4/button.gif" alt="游戏演示界面"></p><h1 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h1><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ol><li>Text（文本）： 设置 Label 显示的文本内容。</li><li>Align（对齐方式）： 设置文本的水平和垂直对齐方式，如左对齐、右对齐、居中等。</li><li>Valign（垂直对齐）： 设置文本的垂直对齐方式，如顶部对齐、底部对齐、居中等。</li><li>Autoscroll（自动滚动）： 布尔值，确定当文本超出 Label 尺寸时是否启用自动滚动显示。</li><li>Clip Text（剪辑文本）： 布尔值，确定当文本超出 Label 尺寸时是否裁剪超出的部分。</li><li>Lines（行数）： 设置 Label 显示的文本行数，当文本内容多于指定行数时，可以自动换行显示。</li></ol><h2 id="样式和外观属性"><a href="#样式和外观属性" class="headerlink" title="样式和外观属性"></a>样式和外观属性</h2><ol><li>Custom Fonts（自定义字体）： 可以选择自定义的字体用于显示文本。</li><li>Font Color（字体颜色）： 设置文本的颜色。</li><li>Font Shadow（字体阴影）： 设置文本的阴影效果，如颜色、偏移量等。</li><li>Font Size（字体大小）： 设置文本的字号大小。</li></ol><h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><ol><li>Rect Min Size（最小尺寸）： 设置 Label 的最小尺寸。</li><li>Visible Characters（可见字符数）： 设置 Label 中可见的字符数，超出部分将被隐藏。</li><li>Percent Visible（可见百分比）： 设置 Label 中可见的百分比文本，用于显示长文本的部分内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">extends Control</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">    # 创建按钮1</span><br><span class="line">    var button1 = Button.new()</span><br><span class="line">    button1.rect_min_size = Vector2(200, 50)</span><br><span class="line">    var normalTexture1 = preload(&quot;res://button1_normal.png&quot;)</span><br><span class="line">    var hoverTexture1 = preload(&quot;res://button1_hover.png&quot;)</span><br><span class="line">    var pressedTexture1 = preload(&quot;res://button1_pressed.png&quot;)</span><br><span class="line">    button1.set_normal_texture(normalTexture1)</span><br><span class="line">    button1.set_hover_texture(hoverTexture1)</span><br><span class="line">    button1.set_pressed_texture(pressedTexture1)</span><br><span class="line">    button1.connect(&quot;pressed&quot;, self, &quot;_on_button_pressed&quot;, [1]) # 连接按钮1的点击事件</span><br><span class="line"></span><br><span class="line">    # 创建按钮2</span><br><span class="line">    var button2 = Button.new()</span><br><span class="line">    button2.rect_min_size = Vector2(200, 50)</span><br><span class="line">    var normalTexture2 = preload(&quot;res://button2_normal.png&quot;)</span><br><span class="line">    var hoverTexture2 = preload(&quot;res://button2_hover.png&quot;)</span><br><span class="line">    var pressedTexture2 = preload(&quot;res://button2_pressed.png&quot;)</span><br><span class="line">    button2.set_normal_texture(normalTexture2)</span><br><span class="line">    button2.set_hover_texture(hoverTexture2)</span><br><span class="line">    button2.set_pressed_texture(pressedTexture2)</span><br><span class="line">    button2.connect(&quot;pressed&quot;, self, &quot;_on_button_pressed&quot;, [2]) # 连接按钮2的点击事件</span><br><span class="line"></span><br><span class="line">    # 将按钮添加到界面上</span><br><span class="line">    add_child(button1)</span><br><span class="line">    add_child(button2)</span><br><span class="line"></span><br><span class="line">func _on_button_pressed(button_id):</span><br><span class="line">    match button_id:</span><br><span class="line">        1:</span><br><span class="line">            print(&quot;点击了按钮1&quot;)</span><br><span class="line">            # 处理按钮1点击事件的逻辑</span><br><span class="line">        2:</span><br><span class="line">            print(&quot;点击了按钮2&quot;)</span><br><span class="line">            # 处理按钮2点击事件的逻辑</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AnimationPlayer OR AnimatedSprite2D</title>
      <link href="/nhycraymond/2023/12/18/Godot4%E8%A7%92%E8%89%B2%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C-AnimationPlayer-OR-AnimatedSprite2D/"/>
      <url>/nhycraymond/2023/12/18/Godot4%E8%A7%92%E8%89%B2%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C-AnimationPlayer-OR-AnimatedSprite2D/</url>
      
        <content type="html"><![CDATA[<p><code>AnimationPlayer</code> 和 <code>AnimatedSprite2D</code> 是 Godot 引擎中用于处理动画的两个不同的类。</p><p><code>AnimationPlayer</code><br>AnimationPlayer 是用于控制和播放各种类型动画的通用工具。<br>它可以在时间轴上管理许多类型的动画片段，包括位移、旋转、缩放、颜色变化、骨骼动画等。<br>通过创建动画轨道（track）并设置关键帧（keyframe），可以对节点属性进行动画化。这使得你能够以非常灵活的方式创建复杂的动画。<br>适用于更广泛的动画需求，可以用于角色动画、UI 动画、物体动画等等。</p><p><code>AnimatedSprite2D</code><br>AnimatedSprite2D 是专门用于精灵动画的类。<br>它适用于简单的、基于帧的动画，即在单个精灵上播放一系列图像以创建动画效果。<br>通常用于实现角色动画的简单运动、攻击、受伤等动作，或者是一些简单的界面元素动画。<br>通过设置动画帧列表（frames）或使用动画表（animation sheet）可以轻松地切换精灵的不同动画帧。<br>本质上，AnimationPlayer 更适用于复杂的、基于属性的动画控制，可以操作节点的多个属性和轨道，而 AnimatedSprite2D 则更适合简单的基于图像帧的动画，主要用于处理单个精灵的动画序列。选择使用哪一个取决于你的具体需求和项目的规模以及复杂性。</p><h1 id="AnimationPlayer"><a href="#AnimationPlayer" class="headerlink" title="AnimationPlayer"></a>AnimationPlayer</h1><ul><li>多种类型的动画支持： 可以处理节点的各种属性动画，包括位置、旋转、缩放、颜色、纹理、骨骼动画等。</li><li>多轨道管理： 允许在同一个 AnimationPlayer 中创建多个轨道，并在每个轨道上分别管理不同的节点属性。</li><li>关键帧控制： 可以在时间轴上设置关键帧，以确定节点属性在不同时间点上的值。</li><li>过渡效果和插值： 支持不同的插值方法和过渡效果，使得关键帧之间的过渡更加平滑。</li><li>时间缩放和控制： 允许控制动画的播放速度、时间缩放，以及在动画播放时暂停、播放、倒放等。</li><li>动画编辑器支持： 内置的动画编辑器可以直观地编辑和管理动画轨道，更容易创建和调整动画效果。</li></ul><p>适用场景：</p><ul><li>角色动画： 用于处理角色的各种动画，包括行走、奔跑、攻击、受伤、死亡等状态动画。</li><li>特效动画： 用于创建复杂的特效动画，如粒子效果、环境动画、天气变化等。</li><li>UI 动画： 用于创建界面元素的动画效果，包括按钮点击、界面切换、菜单动画等。</li><li>游戏场景动画化： 可以控制整个游戏场景中的节点，实现场景中元素的运动、变形、渐变等动画效果。</li></ul><p>优点：</p><ul><li>提供了高度灵活性和控制力，能够创造复杂、精细的动画效果。</li><li>支持多轨道管理，可以同时处理多个节点属性的动画。</li><li>内置的编辑器使得创建、编辑和调整动画非常直观和便捷。</li></ul><p>缺点：</p><ul><li>对于简单的基于帧的动画来说，可能显得过于复杂。</li><li>当需要大量的动画并行时，可能需要小心管理多个轨道，否则会显得混乱。</li></ul><h1 id="AnimatedSprite2D"><a href="#AnimatedSprite2D" class="headerlink" title="AnimatedSprite2D"></a>AnimatedSprite2D</h1><ol><li><p>节点类型：<br>AnimatedSprite2D 是Godot引擎中用于在2D场景中播放动画的节点之一。</p></li><li><p>创建 AnimatedSprite2D 节点：<br>在Godot的场景编辑器中，右键点击场景根节点或其他节点，选择“添加节点（Add Node）”，然后搜索并选择 AnimatedSprite2D 节点，即可创建它。</p></li><li><p>属性和功能：<br>Frames（帧）： AnimatedSprite2D 通过纹理数组来表示动画。你可以将动画的帧作为纹理数组中的元素，每个纹理对应动画的一帧。</p></li></ol><p>Frame Speed（帧速率）： 这个属性用于控制动画的播放速率，即每秒播放的帧数。</p><p>播放控制：</p><p>play(“animation_name”)：通过代码播放指定名称的动画。<br>stop()：停止动画播放。<br>animation_speed：设置动画的播放速度。<br>事件监听： AnimatedSprite2D 可以发出 animation_finished 信号，用于检测动画播放是否完成。</p><ol start="4"><li>使用代码控制动画播放：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 播放动画</span><br><span class="line">$AnimatedSprite.play(&quot;animation_name&quot;)</span><br><span class="line"></span><br><span class="line"># 暂停动画</span><br><span class="line">$AnimatedSprite.stop()</span><br><span class="line"></span><br><span class="line"># 设置播放速度</span><br><span class="line">$AnimatedSprite.animation_speed = 2.0 # 将动画速度设置为原速度的两倍</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5. **使用键帧动画编辑器：**</span><br><span class="line"></span><br><span class="line">可以使用Godot的键帧动画编辑器为 `AnimatedSprite2D` 创建动画轨道，并在时间轴上设置关键帧来控制动画播放、停止、以及动画速度等属性。</span><br><span class="line"></span><br><span class="line">### 6. **事件监听示例：**</span><br><span class="line"></span><br><span class="line"># 当动画播放完成时，触发信号</span><br><span class="line">func _on_AnimatedSprite_animation_finished():</span><br><span class="line">    # 执行相应的操作</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>可以将包含精灵序列帧的图像资源导入到Godot中，然后将其分割成单独的纹理，最后将这些纹理添加到 <code>AnimatedSprite2D</code> 的纹理数组中，以创建动画效果。</p><p><code>AnimatedSprite2D</code> 是一个灵活且强大的2D动画节点，可以通过代码或视图编辑器方便地创建和控制2D动画。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用角色帧动画播放</span><br><span class="line">        animation_player.play(&quot;idle&quot;)</span><br><span class="line">        animation_player.play(&quot;walk&quot;)</span><br><span class="line">        animation_player.play(&quot;attack&quot;)</span><br><span class="line">        animation_player.play(&quot;run&quot;)</span><br><span class="line">        animation_player.play(&quot;jump&quot;)</span><br><span class="line">在Sprite中对角色帧动画进行预分配后, 定义animation_name, 即可在脚本中根据当前状态使用对应的帧动画</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ParallaxBackground 实现视差背景</title>
      <link href="/nhycraymond/2023/12/18/godot-2d-pixcle-game/"/>
      <url>/nhycraymond/2023/12/18/godot-2d-pixcle-game/</url>
      
        <content type="html"><![CDATA[<h1 id="视差背景"><a href="#视差背景" class="headerlink" title="视差背景"></a>视差背景</h1><p><code>ParallaxBackground</code> 是 Godot 引擎中用于创建视差背景效果的节点。它允许你轻松地为场景创建多层背景，并设置它们以不同的速度移动，以实现视差效果。以下是对 ParallaxBackground 的详细讲解：</p><ol><li><p>添加 <code>ParallaxBackground</code> 节点：<br>在 Godot 的场景编辑器中，右键点击场景根节点或者任何其他节点，选择添加节点（Add Node）并搜索 ParallaxBackground，然后添加该节点到场景中。</p></li><li><p>添加 <code>ParallaxLayer</code>：<br>在 ParallaxBackground 下添加 ParallaxLayer 节点。每个 ParallaxLayer 节点代表场景中的一个背景图层，可以包含不同的纹理或精灵。</p></li><li><p>设置纹理或精灵：<br>对于每个 ParallaxLayer 节点，设置其纹理（Texture）或者添加一个 Sprite，用于表示这个背景层。</p></li><li><p>调整视差因子（Parallax Motion）：<br>每个 ParallaxLayer 节点都有一个名为 Parallax motion_scale 的属性。这个值决定了这一层背景相对于相机移动的速度。较小的值会导致更慢的移动，产生更大的视差效果。调整这些值可以实现不同层次之间的差异化移动效果。<br>Scale, 应遵循远景慢,近景快的原则, 所以<code>motion_scale</code>远景应设置的更小, 而近景则稍大</p></li><li><p>设置层次结构：<br>确保 ParallaxLayer 节点按照你期望的顺序进行排列，以创建正确的层次结构和视差效果。通常，较远的背景应该拥有较小的视差因子，而较近的背景应该拥有较大的视差因子。</p></li><li><p>控制相机或容器移动：<br>通过移动包含 ParallaxBackground 的相机或者容器来观察视差效果。当相机移动时，ParallaxLayer 节点将以设置的不同速度移动，从而产生视差效果。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extends ParallaxBackground</span><br><span class="line"></span><br><span class="line">var speed = 50</span><br><span class="line"></span><br><span class="line"># Called every frame. &#x27;delta&#x27; is the elapsed time since the previous frame.</span><br><span class="line">func _process(delta):</span><br><span class="line">scroll_offset.x -= speed * delta</span><br></pre></td></tr></table></figure><p>通过调整相机（或容器）的位置，你将看到添加到 ParallaxLayer 节点的背景图层以不同的速度移动，从而产生出视差背景效果。</p><p><code>ParallaxBackground</code> 的优点在于其直观性和易用性，无需编写复杂的代码或 Shader 即可创建出视差效果。</p>]]></content>
      
      
      <categories>
          
          <category> games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis source code analysis -- server.c</title>
      <link href="/nhycraymond/2023/10/25/redis-source-code-analysis-server-c/"/>
      <url>/nhycraymond/2023/10/25/redis-source-code-analysis-server-c/</url>
      
        <content type="html"><![CDATA[<p>server.c 是 Redis 6.2.6 源代码中的一个核心文件，包含了 Redis 服务器的主要逻辑。下面是对 server.c 文件的详细说明：</p><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>server.c 文件包含了 Redis 服务器的主要逻辑，负责处理客户端请求、命令执行、事件循环、持久化、复制等核心功能。它是 Redis 服务器的入口点，包括以下重要功能：</p><h2 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a><strong>服务器初始化</strong></h2><p>initServer() 函数用于初始化 Redis 服务器。它设置服务器的状态、事件循环、命令表等。</p><h3 id="设置全局状态结构-struct-redisServer"><a href="#设置全局状态结构-struct-redisServer" class="headerlink" title="设置全局状态结构 (struct redisServer)"></a>设置全局状态结构 (struct redisServer)</h3><ul><li>struct redisServer 包含了服务器的配置选项，如端口号、监听地址、数据库数量、日志级别、客户端限制等。在初始化过程中，这些配置选项被设置为默认值。</li></ul><h3 id="初始化事件循环-aeEventLoop"><a href="#初始化事件循环-aeEventLoop" class="headerlink" title="初始化事件循环 (aeEventLoop)"></a>初始化事件循环 (aeEventLoop)</h3><ul><li>struct redisServer 包含了大量的全局状态信息，如服务器的运行状态、数据类型信息、事件循环、命令表等。在初始化过程中，这些状态信息被初始化。</li></ul><h3 id="设置默认配置参数"><a href="#设置默认配置参数" class="headerlink" title="设置默认配置参数"></a>设置默认配置参数</h3><ul><li>Redis 支持多个数据库，每个数据库都有一个 redisDb 结构表示。struct redisServer 包含一个指向数据库列表的指针。在初始化过程中，数据库列表被分配和初始化，通常有默认的一个数据库。</li></ul><h3 id="分配和初始化数据结构"><a href="#分配和初始化数据结构" class="headerlink" title="分配和初始化数据结构"></a>分配和初始化数据结构</h3><ul><li>Redis 命令表是一个哈希表，包含了所有支持的命令及其处理函数。struct redisServer 包含了命令表的指针。在初始化过程中，命令表被分配和初始化，以便服务器能够查找和执行命令。</li></ul><h3 id="加载或创建持久化文件"><a href="#加载或创建持久化文件" class="headerlink" title="加载或创建持久化文件"></a>加载或创建持久化文件</h3><ul><li>Redis 使用事件驱动的方式来处理请求和事件。struct redisServer 包含了事件循环（aeEventLoop）的指针。在初始化过程中，事件循环被创建和初始化，以处理套接字事件和定时事件。</li></ul><h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h3><ul><li>struct redisServer 包含了许多数据结构的指针，如时间处理、持久化处理、内存管理等。这些数据结构在初始化过程中被分配和初始化</li></ul><h3 id="启动事件循环"><a href="#启动事件循环" class="headerlink" title="启动事件循环"></a>启动事件循环</h3><ul><li>struct redisServer 包含了用于处理各种信号（如中断信号、终止信号）的处理函数。这些函数在初始化过程中被设置，以便服务器可以正确响应信号。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>server.c 文件定义了许多数据结构，包括 struct redisServer、struct client、struct redisCommand 等，用于管理服务器状态、客户端连接和命令信息。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p><strong>初始化服务器配置</strong>: 在处理事件循环之前，server.c首先加载和解析Redis服务器的配置文件，配置服务器的各种参数，例如端口、持久化选项、数据存储路径等。</p><p><strong>创建事件循环</strong>：Redis使用了事件驱动的编程模型，基于Epoll、Kqueue或者Select等系统调用。它会创建一个事件循环（Event Loop），用于监听客户端的请求、执行命令和处理其他事件。</p><p><strong>设置事件处理函数</strong>：Redis通过aeCreateFileEvent函数将事件（如套接字上的数据到达、定时事件、信号事件等）与相应的事件处理函数关联起来。这些处理函数通常位于不同的文件中，包括networking.c和其他模块。</p><p><strong>进入事件循环</strong>：server.c通过aeMain函数进入事件循环，开始监听和处理事件。事件循环会不断地检查事件，然后调用相应的事件处理函数。如果有新的客户端连接、命令请求等，事件循环会触发相应的处理函数。</p><p><strong>事件处理</strong>：在事件循环中，Redis服务器会监听来自客户端的请求，包括查询和修改数据的命令。它会执行这些命令，然后将结果返回给客户端。</p><p><strong>定时事件处理</strong>：Redis还支持定时事件，例如定期持久化数据、清理过期数据等。这些事件在事件循环中由相应的处理函数触发。</p><p><strong>信号事件处理</strong>：服务器还可以处理操作系统发送的信号，例如关闭、重载、快照等信号。server.c负责注册信号处理函数，以便在收到信号时执行相应的操作。</p><p><strong>事件循环的退出</strong>：Redis事件循环可以通过不同的方式退出，例如正常关闭、接收到退出信号等。在退出前，服务器会执行清理操作，释放资源，确保数据的完整性。</p><p><strong>释放资源</strong>：最后，server.c负责释放服务器运行期间占用的资源，关闭监听套接字，释放数据结构等。</p><p>总的来说，Redis的server.c是Redis服务器的核心部分，它通过事件循环实现了服务器的主要功能，包括接收客户端请求、执行命令、处理定时任务和信号等。这种事件驱动的架构使得Redis能够高效处理大量客户端请求，成为一个高性能的键值存储系统。</p><h2 id="struct-redisServer"><a href="#struct-redisServer" class="headerlink" title="struct redisServer"></a>struct redisServer</h2><p>描述：Redis 服务器的主要状态结构，包括了服务器的全局状态信息和配置选项。<br>方法：</p><ul><li>initServer() 用于初始化服务器</li><li>serverCron() 用于定时任务的处理</li><li>processCommand() 用于处理客户端发送的命令等。</li></ul><h2 id="struct-client"><a href="#struct-client" class="headerlink" title="struct client"></a>struct client</h2><p>描述：Redis 客户端连接的状态结构，用于管理客户端的状态信息，包括套接字描述符、输入缓冲区、输出缓冲区等。<br>方法：</p><ul><li>processInputBuffer() 用于处理客户端发送的请求</li><li>addReply() 用于向客户端发送响应等。</li></ul><h2 id="struct-redisCommand："><a href="#struct-redisCommand：" class="headerlink" title="struct redisCommand："></a>struct redisCommand：</h2><p>描述：Redis 支持的命令结构，包括命令名称、命令处理函数等。<br>方法：Redis 命令表的查找和执行等。</p><h1 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h1><p>Redis 6.2.6是一个单线程的服务器，它通过事件驱动的方式来处理客户端的命令请求。下面是Redis 6.2.6中如何完成命令处理的详细过程：</p><p><strong>客户端连接和命令请求</strong>：当客户端通过网络连接到Redis服务器时，服务器会接受连接请求，创建一个客户端结构体（client）来代表该连接。客户端可以发送各种Redis命令请求，如GET、SET、HGET等。<br><strong>事件循环</strong>：Redis的服务器主要事件循环（Event Loop）在 ae.c 文件中。该循环不断监听套接字的事件（读取数据）和定时事件。<br><strong>事件处理函数</strong>：当有数据到达客户端套接字时，事件循环调用相应的事件处理函数，如readQueryFromClient。这个函数从套接字读取并解析客户端的命令请求。<br><strong>命令解析</strong>：读取的命令请求是一个文本字符串，服务器需要将其解析成相应的命令和参数。这个解析过程由parseCommand函数执行，它会将命令和参数解析成一个命令对象（redisCommand）。<br><strong>命令执行</strong>：一旦命令被解析，Redis会查找命令对象对应的函数指针，找到对应的命令处理函数。这个函数会执行实际的命令逻辑，访问或修改数据库中的数据。</p><p><strong>数据库访问</strong>：命令处理函数可能需要访问Redis的内部数据库，包括读取、写入数据，执行事务等。Redis的数据库是一个键值存储的数据结构，所有数据都存储在内存中。</p><p><strong>响应构建</strong>：执行命令后，服务器会构建一个响应消息，其中包含了命令执行的结果。这个响应消息会以文本协议（RESP）的格式发送回客户端。</p><p><strong>响应发送</strong>：一旦响应消息被构建，服务器将其写回到客户端套接字，以便客户端能够获取命令的执行结果。</p><p><strong>错误处理</strong>：如果在命令处理的任何阶段发生错误，服务器会构建一个错误响应，将错误信息返回给客户端。客户端可以根据响应来检测命令执行是否成功。</p><p><strong>事件循环继续</strong>：事件循环会继续监听其他客户端的请求或执行其他定时任务。如果没有新的事件，服务器将进入休眠状态等待事件发生。Redis的核心命令处理逻辑集中在redisCommandTable表中，它是一个命令名到命令处理函数的映射表。每个命令都有一个对应的处理函数，可以通过查找命令名来获取。</p><p>下面是一个示例代码片段，演示了如何从客户端读取命令、解析命令、执行命令并发送响应（这里仅作为示例，真正的Redis代码更为复杂）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processClient</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 从客户端套接字读取命令</span></span><br><span class="line">    <span class="keyword">if</span> (readQueryFromClient(c) != REDIS_OK) &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析命令</span></span><br><span class="line">    redisCommand *cmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">        <span class="comment">// 命令不存在，发送错误响应</span></span><br><span class="line">        addReplyError(c, <span class="string">&quot;Unknown command&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (call(c, cmd) != REDIS_OK) &#123;</span><br><span class="line">        <span class="comment">// 命令执行出错，发送错误响应</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h1><h1 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h1><h1 id="响应发送"><a href="#响应发送" class="headerlink" title="响应发送"></a>响应发送</h1>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis source code analysis -- dict.c</title>
      <link href="/nhycraymond/2023/10/23/RedisSourceCodeAnalysis/"/>
      <url>/nhycraymond/2023/10/23/RedisSourceCodeAnalysis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构设计"><a href="#Redis数据结构设计" class="headerlink" title="Redis数据结构设计"></a>Redis数据结构设计</h1><p>Redis中的键值存储是基于字典数据结构实现的。在Redis的源代码中，dict.c文件包含了字典的实现代码，该字典用于存储键值对<br>dict.c 是 Redis 中负责实现字典（哈希表）数据结构的核心文件。字典是 Redis 中键值对的基本存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dict.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希表结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">/* 哈希表数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">/* 哈希表大小，即数组长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">/* 哈希表大小掩码，用于计算索引值 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">/* 已使用的节点数量 */</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字典结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">/* 数据类型特定函数集 */</span></span><br><span class="line">    <span class="type">void</span> *privdata; <span class="comment">/* 数据类型特定的私有数据 */</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">/* 两个哈希表，用于实现渐进式 rehash */</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehash 进度标识 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* 正在运行的迭代器数量 */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希表节点结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">/* 键 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v; <span class="comment">/* 值，可以是指针、64 位无符号整数或 64 位有符号整数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">/* 指向下一个哈希冲突的节点，形成链表 */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希函数特定的接口，比如哈希表的节点可以使用不同的哈希函数 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key); <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key); <span class="comment">/* 复制键的函数 */</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj); <span class="comment">/* 复制值的函数 */</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2); <span class="comment">/* 比较键的函数 */</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key); <span class="comment">/* 销毁键的函数 */</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj); <span class="comment">/* 销毁值的函数 */</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码片段定义了 dict.c 文件中使用的数据结构，包括字典、哈希表、哈希表节点，以及哈希函数特定的接口。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><strong>dictht 结构</strong></p><ul><li>dictht 结构表示哈希表，包括一个指向<strong>哈希表数组的指针table</strong>，<strong>哈希表大小 size</strong>，<strong>大小掩码 sizemask 用于计算索引</strong>，以及<strong>已使用的节点数量 used</strong></li></ul><p><strong>dict 结构</strong></p><ul><li>dict 结构代表整个字典。它包括一个数据类型特定<strong>函数集 dictType</strong>，指向特定数据类型的<strong>私有数据的指针 privdata</strong>，两个哈希表 <strong>ht[2] 用于实现渐进式 rehash，rehashidx 用于跟踪 rehash 进度</strong>，以及 <strong>iterators 记录正在运行的迭代器数量</strong></li></ul><p><strong>dictEntry 结构</strong></p><ul><li>dictEntry 结构表示哈希表中的一个节点，包括键 key、值 v，以及指向下一个哈希冲突的节点的指针 next。这里的值 v 是一个联合体，可以是指针、64 位无符号整数或 64 位有符号整数</li></ul><p><strong>dictType 结构</strong></p><ul><li>dictType 结构<strong>定义了哈希函数特定的接口</strong>，这些接口包括<strong>哈希函数</strong>、<strong>复制键和值的函数</strong>、<strong>比较键的函数</strong>，以及<strong>销毁键和值的函数</strong></li></ul><p>Redis的dict.c文件包含了用于实现字典（哈希表）数据结构的许多函数。以下是一些dict.c中的主要函数，它们用于操作字典、哈希表和哈希表节点。</p><ul><li><strong>dictCreate</strong>： 该函数用于创建一个新的字典。它接受一个指向数据类型特定函数集的指针，这个函数集定义了如何处理键和值。</li><li><strong>dictAdd</strong>： 用于向字典中添加一个键值对。如果键已存在，则函数会更新值。</li><li><strong>dictReplace</strong>： 与dictAdd类似，但仅在键不存在时添加。如果键已存在，它不会执行更新。</li><li><strong>dictDelete</strong>： 删除字典中的指定键值对。</li><li><strong>dictFind</strong>： 查找并返回字典中特定键对应的哈希表节点。</li><li><strong>dictGetKey 和 dictGetVal</strong>： 分别用于获取哈希表节点的键和值。</li><li><strong>dictResize</strong>： 当字典的负载因子超过指定阈值时，这个函数会对字典进行重新哈希，以增加哈希表的大小。</li><li><strong>dictRehash 和 dictRehashMilliseconds</strong>： 这两个函数用于在渐进式rehash期间，将键从旧哈希表rehash到新哈希表。</li><li><strong>dictRelease</strong>： 释放字典中的所有节点，并最终释放字典本身。</li><li><strong>dictGetIterator 和 dictReleaseIterator</strong>： 用于创建和释放迭代器，以遍历字典中的所有键值对。</li><li><strong>dictIteratorNext</strong>： 用于在迭代器上前进到下一个键值对。</li><li><strong>dictGenericDelete</strong>： 通用的删除函数，可以根据指定的标志来删除哈希表中的节点，包括是否释放键和值的内存。</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Redis的哈希表（hash table）在Redis 6.2.6中的接口设计主要包括对外提供的API函数，允许用户与哈希表进行交互。以下是Redis 6.2.6哈希表的一些核心接口和函数</p><p><strong>dictType 结构体</strong>： 这个结构体定义了数据类型特定函数集，包括哈希函数、键复制、值复制、键比较、键销毁和值销毁等函数。用户可以通过dictType结构体来自定义哈希表中键值对的操作方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>dict 结构体</strong> : 这个结构体代表整个哈希表，包括一个指向数据类型特定函数集的指针、指向特定数据类型的私有数据的指针、两个哈希表 ht[2] 用于实现渐进式 rehash、rehashidx 用于跟踪 rehash 进度、以及 iterators 用于记录正在运行的迭代器数量。<br><strong>dictEntry 结构体</strong> : 这个结构体表示哈希表中的一个节点，包括键 key、值 v，以及指向下一个哈希冲突的节点的指针 next。这里的值 v 是一个联合体，可以是指针、64 位无符号整数或 64 位有符号整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字典API函数</strong> : Redis提供了一系列的API函数，允许用户创建、操作和管理哈希表。这些函数包括 dictCreate（创建哈希表）、dictAdd（添加键值对）、dictDelete（删除键值对）、dictFind（查找键值对）、dictGetKey（获取键）、dictGetVal（获取值）、dictGetIterator（创建迭代器）、dictIteratorNext（迭代器遍历）、dictReleaseIterator（释放迭代器）等</p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p>Redis 6.2.6版本中的哈希表节点设计具有以下特点<br><strong>dictEntry 结构体</strong>： 在Redis中，哈希表的每个节点都是一个dictEntry结构体，代表一个键值对。该结构体具有以下字段：</p><p><strong>void *key</strong>：键，可以是任何类型的指针。<br><strong>union</strong>：值，Redis的哈希表支持多种不同的值类型，因此使用了联合体（union）来存储值。值可以是指针、64位无符号整数（uint64_t）或64位有符号整数（int64_t）。<br><strong>struct dictEntry *next</strong>：指向下一个哈希冲突的节点的指针，以形成链表。<br><strong>多值类型支持</strong>： dictEntry结构体中的值字段支持多种类型，这使得Redis的哈希表非常灵活，可以存储不同数据类型的值。<br><strong>泛型设计</strong>： Redis的哈希表节点的设计是泛型的，这意味着它可以存储不同类型的键值对。这种泛型设计是通过void *类型的键字段和值字段实现的，允许用户自定义键和值的数据类型。<br><strong>链表处理哈希冲突</strong>： Redis使用链表来处理哈希冲突。当多个键哈希到同一个桶时，它们将以链表的形式存储在同一个桶中。这使得Redis可以有效地处理多个键具有相同哈希值的情况。</p><blockquote><p>源码中的具体实现： 在Redis的源代码中，dictEntry结构体的具体定义和函数实现可以在dict.c文件中找到。这个文件包含了各种操作哈希表的函数，包括插入、查找、删除、迭代等。通过查看这些源码，可以深入了解dictEntry的设计和实现。</p></blockquote><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>在Redis 6.2.6中，哈希函数的具体实现和设计是基于MurmurHash哈希算法。MurmurHash是一种非加密性的哈希算法，被广泛用于哈希表、散列和数据校验等应用<br><strong>MurmurHash算法</strong>： Redis使用MurmurHash算法作为默认的哈希函数。MurmurHash是一种快速、高效的哈希算法，其设计目标是具有良好的分布性和低碰撞率。<br><strong>32位哈希值</strong>： Redis的MurmurHash实现生成32位的哈希值。这个32位哈希值可以用于确定键在哈希表中的位置。<br><strong>分桶和哈希槽</strong>： Redis的哈希表会将哈希值映射到一组桶（buckets）中，这些桶以哈希槽（slots）的形式组织。Redis会在桶中存储键值对，并通过哈希槽来分布这些桶。<br><strong>一致性哈希</strong>： Redis还使用了一致性哈希算法，它在分布式环境中特别有用。一致性哈希算法将键映射到哈希环（hash ring）上的节点，以便在节点的变化时，最小程度地影响数据的重新分布。<br><strong>哈希函数参数</strong>： 在Redis中，哈希函数通常使用两个参数，一个是键的名称，另一个是用于计算哈希的种子（seed）。这个种子在不同的哈希表操作中保持不变，以确保一致性哈希的准确性。</p><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="/images/redis_dict/redis-dict-uml.png" alt="dict.c"></p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> structure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
