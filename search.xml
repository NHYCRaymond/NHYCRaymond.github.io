<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于ParallaxBackground 实现视差背景</title>
      <link href="/2023/12/18/godot-2d-pixcle-game/"/>
      <url>/2023/12/18/godot-2d-pixcle-game/</url>
      
        <content type="html"><![CDATA[<h1 id="视差背景"><a href="#视差背景" class="headerlink" title="视差背景"></a>视差背景</h1><p><code>ParallaxBackground</code> 是 Godot 引擎中用于创建视差背景效果的节点。它允许你轻松地为场景创建多层背景，并设置它们以不同的速度移动，以实现视差效果。以下是对 ParallaxBackground 的详细讲解：</p><ol><li><p>添加 <code>ParallaxBackground</code> 节点：<br>在 Godot 的场景编辑器中，右键点击场景根节点或者任何其他节点，选择添加节点（Add Node）并搜索 ParallaxBackground，然后添加该节点到场景中。</p></li><li><p>添加 <code>ParallaxLayer</code>：<br>在 ParallaxBackground 下添加 ParallaxLayer 节点。每个 ParallaxLayer 节点代表场景中的一个背景图层，可以包含不同的纹理或精灵。</p></li><li><p>设置纹理或精灵：<br>对于每个 ParallaxLayer 节点，设置其纹理（Texture）或者添加一个 Sprite，用于表示这个背景层。</p></li><li><p>调整视差因子（Parallax Motion）：<br>每个 ParallaxLayer 节点都有一个名为 Parallax motion_scale 的属性。这个值决定了这一层背景相对于相机移动的速度。较小的值会导致更慢的移动，产生更大的视差效果。调整这些值可以实现不同层次之间的差异化移动效果。<br>Scale, 应遵循远景慢,近景快的原则, 所以<code>motion_scale</code>远景应设置的更小, 而近景则稍大</p></li><li><p>设置层次结构：<br>确保 ParallaxLayer 节点按照你期望的顺序进行排列，以创建正确的层次结构和视差效果。通常，较远的背景应该拥有较小的视差因子，而较近的背景应该拥有较大的视差因子。</p></li><li><p>控制相机或容器移动：<br>通过移动包含 ParallaxBackground 的相机或者容器来观察视差效果。当相机移动时，ParallaxLayer 节点将以设置的不同速度移动，从而产生视差效果。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extends ParallaxBackground</span><br><span class="line"></span><br><span class="line">var speed = 50</span><br><span class="line"></span><br><span class="line"># Called every frame. &#x27;delta&#x27; is the elapsed time since the previous frame.</span><br><span class="line">func _process(delta):</span><br><span class="line">scroll_offset.x -= speed * delta</span><br></pre></td></tr></table></figure><p>通过调整相机（或容器）的位置，你将看到添加到 ParallaxLayer 节点的背景图层以不同的速度移动，从而产生出视差背景效果。</p><p><code>ParallaxBackground</code> 的优点在于其直观性和易用性，无需编写复杂的代码或 Shader 即可创建出视差效果。</p>]]></content>
      
      
      <categories>
          
          <category> godot4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> games </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis source code analysis -- server.c</title>
      <link href="/2023/10/25/redis-source-code-analysis-server-c/"/>
      <url>/2023/10/25/redis-source-code-analysis-server-c/</url>
      
        <content type="html"><![CDATA[<p>server.c 是 Redis 6.2.6 源代码中的一个核心文件，包含了 Redis 服务器的主要逻辑。下面是对 server.c 文件的详细说明：</p><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>server.c 文件包含了 Redis 服务器的主要逻辑，负责处理客户端请求、命令执行、事件循环、持久化、复制等核心功能。它是 Redis 服务器的入口点，包括以下重要功能：</p><h2 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a><strong>服务器初始化</strong></h2><p>initServer() 函数用于初始化 Redis 服务器。它设置服务器的状态、事件循环、命令表等。</p><h3 id="设置全局状态结构-struct-redisServer"><a href="#设置全局状态结构-struct-redisServer" class="headerlink" title="设置全局状态结构 (struct redisServer)"></a>设置全局状态结构 (struct redisServer)</h3><ul><li>struct redisServer 包含了服务器的配置选项，如端口号、监听地址、数据库数量、日志级别、客户端限制等。在初始化过程中，这些配置选项被设置为默认值。</li></ul><h3 id="初始化事件循环-aeEventLoop"><a href="#初始化事件循环-aeEventLoop" class="headerlink" title="初始化事件循环 (aeEventLoop)"></a>初始化事件循环 (aeEventLoop)</h3><ul><li>struct redisServer 包含了大量的全局状态信息，如服务器的运行状态、数据类型信息、事件循环、命令表等。在初始化过程中，这些状态信息被初始化。</li></ul><h3 id="设置默认配置参数"><a href="#设置默认配置参数" class="headerlink" title="设置默认配置参数"></a>设置默认配置参数</h3><ul><li>Redis 支持多个数据库，每个数据库都有一个 redisDb 结构表示。struct redisServer 包含一个指向数据库列表的指针。在初始化过程中，数据库列表被分配和初始化，通常有默认的一个数据库。</li></ul><h3 id="分配和初始化数据结构"><a href="#分配和初始化数据结构" class="headerlink" title="分配和初始化数据结构"></a>分配和初始化数据结构</h3><ul><li>Redis 命令表是一个哈希表，包含了所有支持的命令及其处理函数。struct redisServer 包含了命令表的指针。在初始化过程中，命令表被分配和初始化，以便服务器能够查找和执行命令。</li></ul><h3 id="加载或创建持久化文件"><a href="#加载或创建持久化文件" class="headerlink" title="加载或创建持久化文件"></a>加载或创建持久化文件</h3><ul><li>Redis 使用事件驱动的方式来处理请求和事件。struct redisServer 包含了事件循环（aeEventLoop）的指针。在初始化过程中，事件循环被创建和初始化，以处理套接字事件和定时事件。</li></ul><h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h3><ul><li>struct redisServer 包含了许多数据结构的指针，如时间处理、持久化处理、内存管理等。这些数据结构在初始化过程中被分配和初始化</li></ul><h3 id="启动事件循环"><a href="#启动事件循环" class="headerlink" title="启动事件循环"></a>启动事件循环</h3><ul><li>struct redisServer 包含了用于处理各种信号（如中断信号、终止信号）的处理函数。这些函数在初始化过程中被设置，以便服务器可以正确响应信号。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>server.c 文件定义了许多数据结构，包括 struct redisServer、struct client、struct redisCommand 等，用于管理服务器状态、客户端连接和命令信息。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p><strong>初始化服务器配置</strong>: 在处理事件循环之前，server.c首先加载和解析Redis服务器的配置文件，配置服务器的各种参数，例如端口、持久化选项、数据存储路径等。</p><p><strong>创建事件循环</strong>：Redis使用了事件驱动的编程模型，基于Epoll、Kqueue或者Select等系统调用。它会创建一个事件循环（Event Loop），用于监听客户端的请求、执行命令和处理其他事件。</p><p><strong>设置事件处理函数</strong>：Redis通过aeCreateFileEvent函数将事件（如套接字上的数据到达、定时事件、信号事件等）与相应的事件处理函数关联起来。这些处理函数通常位于不同的文件中，包括networking.c和其他模块。</p><p><strong>进入事件循环</strong>：server.c通过aeMain函数进入事件循环，开始监听和处理事件。事件循环会不断地检查事件，然后调用相应的事件处理函数。如果有新的客户端连接、命令请求等，事件循环会触发相应的处理函数。</p><p><strong>事件处理</strong>：在事件循环中，Redis服务器会监听来自客户端的请求，包括查询和修改数据的命令。它会执行这些命令，然后将结果返回给客户端。</p><p><strong>定时事件处理</strong>：Redis还支持定时事件，例如定期持久化数据、清理过期数据等。这些事件在事件循环中由相应的处理函数触发。</p><p><strong>信号事件处理</strong>：服务器还可以处理操作系统发送的信号，例如关闭、重载、快照等信号。server.c负责注册信号处理函数，以便在收到信号时执行相应的操作。</p><p><strong>事件循环的退出</strong>：Redis事件循环可以通过不同的方式退出，例如正常关闭、接收到退出信号等。在退出前，服务器会执行清理操作，释放资源，确保数据的完整性。</p><p><strong>释放资源</strong>：最后，server.c负责释放服务器运行期间占用的资源，关闭监听套接字，释放数据结构等。</p><p>总的来说，Redis的server.c是Redis服务器的核心部分，它通过事件循环实现了服务器的主要功能，包括接收客户端请求、执行命令、处理定时任务和信号等。这种事件驱动的架构使得Redis能够高效处理大量客户端请求，成为一个高性能的键值存储系统。</p><h2 id="struct-redisServer"><a href="#struct-redisServer" class="headerlink" title="struct redisServer"></a>struct redisServer</h2><p>描述：Redis 服务器的主要状态结构，包括了服务器的全局状态信息和配置选项。<br>方法：</p><ul><li>initServer() 用于初始化服务器</li><li>serverCron() 用于定时任务的处理</li><li>processCommand() 用于处理客户端发送的命令等。</li></ul><h2 id="struct-client"><a href="#struct-client" class="headerlink" title="struct client"></a>struct client</h2><p>描述：Redis 客户端连接的状态结构，用于管理客户端的状态信息，包括套接字描述符、输入缓冲区、输出缓冲区等。<br>方法：</p><ul><li>processInputBuffer() 用于处理客户端发送的请求</li><li>addReply() 用于向客户端发送响应等。</li></ul><h2 id="struct-redisCommand："><a href="#struct-redisCommand：" class="headerlink" title="struct redisCommand："></a>struct redisCommand：</h2><p>描述：Redis 支持的命令结构，包括命令名称、命令处理函数等。<br>方法：Redis 命令表的查找和执行等。</p><h1 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h1><p>Redis 6.2.6是一个单线程的服务器，它通过事件驱动的方式来处理客户端的命令请求。下面是Redis 6.2.6中如何完成命令处理的详细过程：</p><p><strong>客户端连接和命令请求</strong>：当客户端通过网络连接到Redis服务器时，服务器会接受连接请求，创建一个客户端结构体（client）来代表该连接。客户端可以发送各种Redis命令请求，如GET、SET、HGET等。<br><strong>事件循环</strong>：Redis的服务器主要事件循环（Event Loop）在 ae.c 文件中。该循环不断监听套接字的事件（读取数据）和定时事件。<br><strong>事件处理函数</strong>：当有数据到达客户端套接字时，事件循环调用相应的事件处理函数，如readQueryFromClient。这个函数从套接字读取并解析客户端的命令请求。<br><strong>命令解析</strong>：读取的命令请求是一个文本字符串，服务器需要将其解析成相应的命令和参数。这个解析过程由parseCommand函数执行，它会将命令和参数解析成一个命令对象（redisCommand）。<br><strong>命令执行</strong>：一旦命令被解析，Redis会查找命令对象对应的函数指针，找到对应的命令处理函数。这个函数会执行实际的命令逻辑，访问或修改数据库中的数据。</p><p><strong>数据库访问</strong>：命令处理函数可能需要访问Redis的内部数据库，包括读取、写入数据，执行事务等。Redis的数据库是一个键值存储的数据结构，所有数据都存储在内存中。</p><p><strong>响应构建</strong>：执行命令后，服务器会构建一个响应消息，其中包含了命令执行的结果。这个响应消息会以文本协议（RESP）的格式发送回客户端。</p><p><strong>响应发送</strong>：一旦响应消息被构建，服务器将其写回到客户端套接字，以便客户端能够获取命令的执行结果。</p><p><strong>错误处理</strong>：如果在命令处理的任何阶段发生错误，服务器会构建一个错误响应，将错误信息返回给客户端。客户端可以根据响应来检测命令执行是否成功。</p><p><strong>事件循环继续</strong>：事件循环会继续监听其他客户端的请求或执行其他定时任务。如果没有新的事件，服务器将进入休眠状态等待事件发生。Redis的核心命令处理逻辑集中在redisCommandTable表中，它是一个命令名到命令处理函数的映射表。每个命令都有一个对应的处理函数，可以通过查找命令名来获取。</p><p>下面是一个示例代码片段，演示了如何从客户端读取命令、解析命令、执行命令并发送响应（这里仅作为示例，真正的Redis代码更为复杂）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processClient</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 从客户端套接字读取命令</span></span><br><span class="line">    <span class="keyword">if</span> (readQueryFromClient(c) != REDIS_OK) &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析命令</span></span><br><span class="line">    redisCommand *cmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">        <span class="comment">// 命令不存在，发送错误响应</span></span><br><span class="line">        addReplyError(c, <span class="string">&quot;Unknown command&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (call(c, cmd) != REDIS_OK) &#123;</span><br><span class="line">        <span class="comment">// 命令执行出错，发送错误响应</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h1><h1 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h1><h1 id="响应发送"><a href="#响应发送" class="headerlink" title="响应发送"></a>响应发送</h1>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis source code analysis -- dict.c</title>
      <link href="/2023/10/23/RedisSourceCodeAnalysis/"/>
      <url>/2023/10/23/RedisSourceCodeAnalysis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构设计"><a href="#Redis数据结构设计" class="headerlink" title="Redis数据结构设计"></a>Redis数据结构设计</h1><p>Redis中的键值存储是基于字典数据结构实现的。在Redis的源代码中，dict.c文件包含了字典的实现代码，该字典用于存储键值对<br>dict.c 是 Redis 中负责实现字典（哈希表）数据结构的核心文件。字典是 Redis 中键值对的基本存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dict.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希表结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">/* 哈希表数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">/* 哈希表大小，即数组长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">/* 哈希表大小掩码，用于计算索引值 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">/* 已使用的节点数量 */</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字典结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">/* 数据类型特定函数集 */</span></span><br><span class="line">    <span class="type">void</span> *privdata; <span class="comment">/* 数据类型特定的私有数据 */</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">/* 两个哈希表，用于实现渐进式 rehash */</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehash 进度标识 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* 正在运行的迭代器数量 */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希表节点结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">/* 键 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v; <span class="comment">/* 值，可以是指针、64 位无符号整数或 64 位有符号整数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">/* 指向下一个哈希冲突的节点，形成链表 */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希函数特定的接口，比如哈希表的节点可以使用不同的哈希函数 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key); <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key); <span class="comment">/* 复制键的函数 */</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj); <span class="comment">/* 复制值的函数 */</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2); <span class="comment">/* 比较键的函数 */</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key); <span class="comment">/* 销毁键的函数 */</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj); <span class="comment">/* 销毁值的函数 */</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码片段定义了 dict.c 文件中使用的数据结构，包括字典、哈希表、哈希表节点，以及哈希函数特定的接口。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><strong>dictht 结构</strong></p><ul><li>dictht 结构表示哈希表，包括一个指向<strong>哈希表数组的指针table</strong>，<strong>哈希表大小 size</strong>，<strong>大小掩码 sizemask 用于计算索引</strong>，以及<strong>已使用的节点数量 used</strong></li></ul><p><strong>dict 结构</strong></p><ul><li>dict 结构代表整个字典。它包括一个数据类型特定<strong>函数集 dictType</strong>，指向特定数据类型的<strong>私有数据的指针 privdata</strong>，两个哈希表 <strong>ht[2] 用于实现渐进式 rehash，rehashidx 用于跟踪 rehash 进度</strong>，以及 <strong>iterators 记录正在运行的迭代器数量</strong></li></ul><p><strong>dictEntry 结构</strong></p><ul><li>dictEntry 结构表示哈希表中的一个节点，包括键 key、值 v，以及指向下一个哈希冲突的节点的指针 next。这里的值 v 是一个联合体，可以是指针、64 位无符号整数或 64 位有符号整数</li></ul><p><strong>dictType 结构</strong></p><ul><li>dictType 结构<strong>定义了哈希函数特定的接口</strong>，这些接口包括<strong>哈希函数</strong>、<strong>复制键和值的函数</strong>、<strong>比较键的函数</strong>，以及<strong>销毁键和值的函数</strong></li></ul><p>Redis的dict.c文件包含了用于实现字典（哈希表）数据结构的许多函数。以下是一些dict.c中的主要函数，它们用于操作字典、哈希表和哈希表节点。</p><ul><li><strong>dictCreate</strong>： 该函数用于创建一个新的字典。它接受一个指向数据类型特定函数集的指针，这个函数集定义了如何处理键和值。</li><li><strong>dictAdd</strong>： 用于向字典中添加一个键值对。如果键已存在，则函数会更新值。</li><li><strong>dictReplace</strong>： 与dictAdd类似，但仅在键不存在时添加。如果键已存在，它不会执行更新。</li><li><strong>dictDelete</strong>： 删除字典中的指定键值对。</li><li><strong>dictFind</strong>： 查找并返回字典中特定键对应的哈希表节点。</li><li><strong>dictGetKey 和 dictGetVal</strong>： 分别用于获取哈希表节点的键和值。</li><li><strong>dictResize</strong>： 当字典的负载因子超过指定阈值时，这个函数会对字典进行重新哈希，以增加哈希表的大小。</li><li><strong>dictRehash 和 dictRehashMilliseconds</strong>： 这两个函数用于在渐进式rehash期间，将键从旧哈希表rehash到新哈希表。</li><li><strong>dictRelease</strong>： 释放字典中的所有节点，并最终释放字典本身。</li><li><strong>dictGetIterator 和 dictReleaseIterator</strong>： 用于创建和释放迭代器，以遍历字典中的所有键值对。</li><li><strong>dictIteratorNext</strong>： 用于在迭代器上前进到下一个键值对。</li><li><strong>dictGenericDelete</strong>： 通用的删除函数，可以根据指定的标志来删除哈希表中的节点，包括是否释放键和值的内存。</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Redis的哈希表（hash table）在Redis 6.2.6中的接口设计主要包括对外提供的API函数，允许用户与哈希表进行交互。以下是Redis 6.2.6哈希表的一些核心接口和函数</p><p><strong>dictType 结构体</strong>： 这个结构体定义了数据类型特定函数集，包括哈希函数、键复制、值复制、键比较、键销毁和值销毁等函数。用户可以通过dictType结构体来自定义哈希表中键值对的操作方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>dict 结构体</strong> : 这个结构体代表整个哈希表，包括一个指向数据类型特定函数集的指针、指向特定数据类型的私有数据的指针、两个哈希表 ht[2] 用于实现渐进式 rehash、rehashidx 用于跟踪 rehash 进度、以及 iterators 用于记录正在运行的迭代器数量。<br><strong>dictEntry 结构体</strong> : 这个结构体表示哈希表中的一个节点，包括键 key、值 v，以及指向下一个哈希冲突的节点的指针 next。这里的值 v 是一个联合体，可以是指针、64 位无符号整数或 64 位有符号整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字典API函数</strong> : Redis提供了一系列的API函数，允许用户创建、操作和管理哈希表。这些函数包括 dictCreate（创建哈希表）、dictAdd（添加键值对）、dictDelete（删除键值对）、dictFind（查找键值对）、dictGetKey（获取键）、dictGetVal（获取值）、dictGetIterator（创建迭代器）、dictIteratorNext（迭代器遍历）、dictReleaseIterator（释放迭代器）等</p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p>Redis 6.2.6版本中的哈希表节点设计具有以下特点<br><strong>dictEntry 结构体</strong>： 在Redis中，哈希表的每个节点都是一个dictEntry结构体，代表一个键值对。该结构体具有以下字段：</p><p><strong>void *key</strong>：键，可以是任何类型的指针。<br><strong>union</strong>：值，Redis的哈希表支持多种不同的值类型，因此使用了联合体（union）来存储值。值可以是指针、64位无符号整数（uint64_t）或64位有符号整数（int64_t）。<br><strong>struct dictEntry *next</strong>：指向下一个哈希冲突的节点的指针，以形成链表。<br><strong>多值类型支持</strong>： dictEntry结构体中的值字段支持多种类型，这使得Redis的哈希表非常灵活，可以存储不同数据类型的值。<br><strong>泛型设计</strong>： Redis的哈希表节点的设计是泛型的，这意味着它可以存储不同类型的键值对。这种泛型设计是通过void *类型的键字段和值字段实现的，允许用户自定义键和值的数据类型。<br><strong>链表处理哈希冲突</strong>： Redis使用链表来处理哈希冲突。当多个键哈希到同一个桶时，它们将以链表的形式存储在同一个桶中。这使得Redis可以有效地处理多个键具有相同哈希值的情况。</p><blockquote><p>源码中的具体实现： 在Redis的源代码中，dictEntry结构体的具体定义和函数实现可以在dict.c文件中找到。这个文件包含了各种操作哈希表的函数，包括插入、查找、删除、迭代等。通过查看这些源码，可以深入了解dictEntry的设计和实现。</p></blockquote><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>在Redis 6.2.6中，哈希函数的具体实现和设计是基于MurmurHash哈希算法。MurmurHash是一种非加密性的哈希算法，被广泛用于哈希表、散列和数据校验等应用<br><strong>MurmurHash算法</strong>： Redis使用MurmurHash算法作为默认的哈希函数。MurmurHash是一种快速、高效的哈希算法，其设计目标是具有良好的分布性和低碰撞率。<br><strong>32位哈希值</strong>： Redis的MurmurHash实现生成32位的哈希值。这个32位哈希值可以用于确定键在哈希表中的位置。<br><strong>分桶和哈希槽</strong>： Redis的哈希表会将哈希值映射到一组桶（buckets）中，这些桶以哈希槽（slots）的形式组织。Redis会在桶中存储键值对，并通过哈希槽来分布这些桶。<br><strong>一致性哈希</strong>： Redis还使用了一致性哈希算法，它在分布式环境中特别有用。一致性哈希算法将键映射到哈希环（hash ring）上的节点，以便在节点的变化时，最小程度地影响数据的重新分布。<br><strong>哈希函数参数</strong>： 在Redis中，哈希函数通常使用两个参数，一个是键的名称，另一个是用于计算哈希的种子（seed）。这个种子在不同的哈希表操作中保持不变，以确保一致性哈希的准确性。</p><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="/images/redis_dict/redis-dict-uml.png" alt="dict.c"></p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> structure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
